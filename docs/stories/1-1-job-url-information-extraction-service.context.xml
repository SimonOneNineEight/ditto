<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1</storyId>
    <title>Job URL Information Extraction Service</title>
    <status>drafted</status>
    <generatedAt>2025-12-30</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/1-1-job-url-information-extraction-service.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a job seeker</asA>
    <iWant>to paste a job posting URL and have the job details automatically extracted</iWant>
    <soThat>I can save time on manual data entry and quickly capture opportunities</soThat>
    <tasks>
      <task id="1">Create URL extraction service infrastructure</task>
      <task id="2">Implement platform-specific parsers</task>
      <task id="3">Build HTTP client with timeout controls</task>
      <task id="4">Create extraction API endpoint</task>
      <task id="5">Error handling and logging</task>
      <task id="6">Unit tests for extraction service</task>
      <task id="7">Integration tests for API endpoint</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC-1">Accept URLs from supported platforms (LinkedIn, Indeed, Glassdoor, AngelList)</criterion>
    <criterion id="AC-2">Extract job title, company name, location, and job description within 10 seconds</criterion>
    <criterion id="AC-3">Return structured JSON data with extracted fields</criterion>
    <criterion id="AC-4">Handle extraction failures gracefully with clear error messages</criterion>
    <criterion id="AC-5">Return partial data if some fields cannot be extracted</criterion>
    <criterion id="AC-6">Validate URL format before attempting extraction</criterion>
    <criterion id="AC-7">Implement timeout protection (10-second hard limit per PRD NFR-1.2)</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/PRD.md" title="Product Requirements Document">
        <section name="FR-1.2: URL Extraction">
          Functional requirement for job posting URL extraction. Specifies supported platforms (LinkedIn, Indeed, Glassdoor, AngelList), 10-second timeout, and automatic field extraction. Critical for quick application capture workflow.
        </section>
        <section name="NFR-1.2: API Performance">
          API response time target: &lt;500ms (90th percentile). Extraction service must be optimized for performance while respecting 10-second hard timeout for external HTTP requests.
        </section>
        <section name="NFR-2.5: Rate Limiting">
          30 URL extractions per user per day. 100 requests/minute general API limit. Return 429 Too Many Requests with Retry-After header when exceeded.
        </section>
        <section name="NFR-3.3: Error Handling">
          User-friendly error messages with actionable guidance. Avoid technical jargon in API responses.
        </section>
        <section name="NFR-5.3: Test Coverage">
          70%+ unit test coverage target for all new code.
        </section>
      </doc>

      <doc path="docs/architecture.md" title="Architecture Document">
        <section name="Technology Stack">
          Go 1.23 backend with Gin framework. PostgreSQL database. Existing auth infrastructure (JWT + OAuth). Use standard library where possible.
        </section>
        <section name="API Structure">
          All endpoints under /api/v1/ prefix. RESTful conventions. Standardized error format: {error, code, details}.
        </section>
        <section name="Error Handling">
          Consistent error response format across all endpoints. Use HTTP status codes appropriately (400, 408, 429, 500).
        </section>
        <section name="Logging">
          Structured logging with JSON output. Log extraction attempts with platform, duration, success/failure for monitoring.
        </section>
      </doc>

      <doc path="docs/implementation-readiness-report-2025-12-30.md" title="Solutioning Gate Check Report">
        <section name="Medium Priority Observation M3: URL Extraction Reliability">
          Implement generic HTML parser as fallback for when platform-specific parsers fail. Add extraction failure monitoring via structured logging. Web scraping is fragile - sites change HTML structure frequently.
        </section>
      </doc>

      <doc path="docs/epics.md" title="Epic Breakdown">
        <section name="Epic 1: Enhanced Application Management">
          Story 1.1 is the foundation for URL extraction. Enables quick application capture workflow (&lt;30s per PRD success criterion). Critical first story for Epic 1.
        </section>
      </doc>
    </docs>

    <code>
      <artifact path="backend/internal/handlers/helpers.go" kind="utility" symbol="respondWithError" lines="">
        <reason>Existing error response helper. Use this pattern for consistent error responses in extraction handler.</reason>
      </artifact>

      <artifact path="backend/internal/middleware/error.go" kind="middleware" symbol="ErrorHandler" lines="">
        <reason>Global error handling middleware. Extraction service errors should integrate with this middleware.</reason>
      </artifact>

      <artifact path="backend/internal/middleware/auth.go" kind="middleware" symbol="RequireAuth" lines="">
        <reason>JWT authentication middleware. Extraction endpoint will require authentication to enforce per-user rate limiting.</reason>
      </artifact>

      <artifact path="backend/internal/handlers/application.go" kind="handler" symbol="CreateApplication" lines="">
        <reason>Existing application creation handler. Extraction service will be called by frontend before creating application (Story 1.3 integration point).</reason>
      </artifact>

      <artifact path="backend/internal/models/application.go" kind="model" symbol="Application" lines="">
        <reason>Application model shows expected fields (Title, Company, Location, Description). Extraction response should map to these fields.</reason>
      </artifact>

      <artifact path="backend/cmd/server/main.go" kind="main" symbol="main" lines="">
        <reason>Server entry point. New extraction route will be registered here in routes setup.</reason>
      </artifact>

      <artifact path="backend/internal/testutil" kind="directory" symbol="" lines="">
        <reason>Test utilities directory. Contains helpers for test database setup, mocking, and fixtures. Use for integration tests.</reason>
      </artifact>
    </code>

    <dependencies>
      <go>
        <existing>
          <package>github.com/gin-gonic/gin v1.10.1</package>
          <package>github.com/lib/pq v1.10.9</package>
          <package>github.com/golang-jwt/jwt/v5 v5.2.2</package>
          <package>github.com/stretchr/testify v1.10.0</package>
        </existing>
        <needed>
          <package>github.com/PuerkitoBio/goquery (HTML parsing library, recommended)</package>
          <package>golang.org/x/net/html (alternative, standard library extension)</package>
        </needed>
      </go>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="architecture">Use existing Gin framework patterns. Follow handler → service → repository layering.</constraint>
    <constraint type="architecture">Place new code in backend/internal/services/url_extractor/ package. Create subdirectory for parsers.</constraint>
    <constraint type="architecture">Handler in backend/internal/handlers/extract_handler.go. Register route in routes package.</constraint>
    <constraint type="performance">10-second hard timeout for HTTP requests (http.Client{Timeout: 10 * time.Second})</constraint>
    <constraint type="performance">API endpoint must respond in &lt;500ms (90th percentile) - most time is external HTTP call</constraint>
    <constraint type="security">Validate URL format before making external requests to prevent SSRF attacks</constraint>
    <constraint type="security">Sanitize extracted HTML content before storing (prevent XSS via malicious job descriptions)</constraint>
    <constraint type="rate-limiting">Implement per-user rate limiting: 30 extractions/day. Store in Redis or PostgreSQL.</constraint>
    <constraint type="error-handling">Use standardized error format: {error, code, details}. Match existing respondWithError pattern.</constraint>
    <constraint type="testing">70%+ unit test coverage. Mock external HTTP calls in tests (do not hit live job sites).</constraint>
    <constraint type="testing">Create test fixtures in testdata/html/ directory with sample HTML from each platform.</constraint>
    <constraint type="logging">Structured logging for all extraction attempts. Log: platform, url_hash, duration, success, error_type.</constraint>
  </constraints>

  <interfaces>
    <interface name="POST /api/v1/extract/job-url" kind="REST endpoint">
      <signature>
Request:
{
  "url": "https://www.linkedin.com/jobs/view/123456"
}

Response (Success):
{
  "success": true,
  "data": {
    "title": "Senior Software Engineer",
    "company": "Tech Corp",
    "location": "San Francisco, CA",
    "description": "We are seeking...",
    "platform": "linkedin"
  },
  "warnings": ["Could not extract salary information"]
}

Response (Error):
{
  "success": false,
  "error": {
    "error": "Invalid URL format",
    "code": "VALIDATION_ERROR",
    "details": ["URL must be from supported platform"]
  }
}
      </signature>
      <path>backend/internal/handlers/extract_handler.go</path>
    </interface>

    <interface name="URLExtractorService.Extract(url string)" kind="service method">
      <signature>
type URLExtractorService interface {
    Extract(ctx context.Context, url string) (*ExtractedJobData, []string, error)
}

// Returns: data, warnings, error
// warnings are non-critical issues (partial extraction)
// error is nil on success or partial success
      </signature>
      <path>backend/internal/services/url_extractor/extractor.go</path>
    </interface>

    <interface name="respondWithError" kind="helper function">
      <signature>
func respondWithError(c *gin.Context, code int, message string)
// Existing helper in handlers/helpers.go
// Use for consistent error responses
      </signature>
      <path>backend/internal/handlers/helpers.go</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Go testing framework with testify assertions. Table-driven tests for multiple scenarios. Mock external dependencies (HTTP calls).
      Test files live alongside source files (*_test.go). Integration tests in backend/tests/ directory.
      Use testutil package for test database setup and fixtures. Target 70%+ coverage (go test -cover).
    </standards>

    <locations>
      <location>backend/internal/services/url_extractor/*_test.go (unit tests)</location>
      <location>backend/tests/integration/extract_test.go (integration tests)</location>
      <location>backend/testdata/html/*.html (test fixtures)</location>
    </locations>

    <ideas>
      <idea ac="AC-1">Test platform detection: valid URLs for LinkedIn, Indeed, Glassdoor, AngelList</idea>
      <idea ac="AC-1">Test unsupported platform: return 400 with error message listing supported platforms</idea>
      <idea ac="AC-2">Test successful extraction from each platform using mock HTML fixtures</idea>
      <idea ac="AC-2">Test timeout scenario: HTTP call exceeds 10 seconds, service returns timeout error</idea>
      <idea ac="AC-3">Test response format: verify JSON structure matches spec (success, data, warnings, error)</idea>
      <idea ac="AC-4">Test network error: HTTP call fails, service returns graceful error</idea>
      <idea ac="AC-5">Test partial extraction: some fields missing from HTML, service returns partial data with warnings</idea>
      <idea ac="AC-6">Test URL validation: invalid format (not a URL), malformed URL, missing protocol</idea>
      <idea ac="AC-7">Test timeout protection: mock HTTP call that hangs, verify 10-second cutoff</idea>
      <idea>Test fallback parser: platform-specific parser fails, generic parser extracts title/description from meta tags</idea>
      <idea>Test rate limiting: user exceeds 30 extractions/day, endpoint returns 429</idea>
      <idea>Test authentication: unauthenticated request returns 401</idea>
      <idea>Test HTML sanitization: malicious script in job description, verify sanitized in response</idea>
    </ideas>
  </tests>
</story-context>
