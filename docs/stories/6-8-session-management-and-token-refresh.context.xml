<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>6</epicId>
    <storyId>8</storyId>
    <title>Session Management and Token Refresh</title>
    <status>drafted</status>
    <generatedAt>2026-02-19</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/6-8-session-management-and-token-refresh.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a user</asA>
    <iWant>my session to stay active while I'm using ditto</iWant>
    <soThat>I don't get logged out unexpectedly while working</soThat>
    <tasks>
      <task id="1" title="Backend — Update token expiration and rotation" acs="5,6,7">
        <subtask id="1.1">Verify/update access token TTL to 24 hours in internal/auth/jwt.go — current default is 15 minutes; update to match NFR-2.1 (24h)</subtask>
        <subtask id="1.2">Verify refresh token TTL is 7 days in internal/auth/jwt.go</subtask>
        <subtask id="1.3">Implement refresh token rotation in the refresh endpoint handler (internal/handlers/auth.go) — on each refresh: generate new refresh token, store in users_auth.refresh_token, invalidate the old token</subtask>
        <subtask id="1.4">Ensure refresh endpoint response includes expires_in field (seconds until access token expiry) so the frontend can track expiration proactively</subtask>
        <subtask id="1.5">Add structured error response for expired/invalid refresh tokens: { "error": "Refresh token expired", "code": "UNAUTHORIZED" }</subtask>
        <subtask id="1.6">go build ./... passes</subtask>
      </task>
      <task id="2" title="Backend — Server-side logout token invalidation" acs="4">
        <subtask id="2.1">Verify/enhance the logout endpoint to clear the refresh token from users_auth.refresh_token in the database, preventing reuse</subtask>
        <subtask id="2.2">Return proper success response on logout</subtask>
        <subtask id="2.3">go build ./... passes</subtask>
      </task>
      <task id="3" title="Frontend — Axios interceptor for automatic token refresh" acs="1,3">
        <subtask id="3.1">Add response interceptor to frontend/src/lib/axios.ts that catches 401 responses, queues the failed request, attempts token refresh, and retries queued requests with the new token</subtask>
        <subtask id="3.2">Implement refresh mutex/queue — if multiple requests fail with 401 simultaneously, only one refresh call is made; other requests wait for the refresh result before retrying</subtask>
        <subtask id="3.3">On refresh failure: clear session via NextAuth signOut(), redirect to login page, show toast: "Session expired. Please log in again."</subtask>
        <subtask id="3.4">Add a flag to prevent infinite refresh loops — do not attempt refresh on the refresh endpoint itself or after a refresh has already failed</subtask>
        <subtask id="3.5">npm run build passes</subtask>
      </task>
      <task id="4" title="Frontend — NextAuth token refresh integration" acs="1,2">
        <subtask id="4.1">Update src/auth.ts JWT callback to store token expiration timestamp from backend response</subtask>
        <subtask id="4.2">Implement proactive token refresh in the JWT callback — when token is accessed and expiry is within 5 minutes, call the refresh endpoint and update stored tokens</subtask>
        <subtask id="4.3">Verify SessionProvider in src/providers/auth-provider.tsx has refetchOnWindowFocus={true}</subtask>
        <subtask id="4.4">Ensure refetchInterval is set appropriately (e.g., 4 minutes) so tokens are refreshed before the 5-minute threshold</subtask>
        <subtask id="4.5">npm run build passes</subtask>
      </task>
      <task id="5" title="Frontend — Logout cleanup" acs="4">
        <subtask id="5.1">Verify the logout flow calls the backend logout endpoint to invalidate the refresh token server-side before calling NextAuth signOut()</subtask>
        <subtask id="5.2">Ensure signOut({ callbackUrl: '/login' }) clears all client-side state and redirects to login</subtask>
        <subtask id="5.3">npm run build passes</subtask>
      </task>
      <task id="6" title="Testing and verification" acs="all">
        <subtask id="6.1">npm run build passes with no TypeScript errors</subtask>
        <subtask id="6.2">go build ./... passes with no Go compilation errors</subtask>
        <subtask id="6.3">Manual test: login, verify access token has 24h expiry</subtask>
        <subtask id="6.4">Manual test: verify auto-refresh happens transparently near expiry</subtask>
        <subtask id="6.5">Manual test: open ditto in two browser tabs, verify both tabs maintain session</subtask>
        <subtask id="6.6">Manual test: invalidate refresh token server-side, verify redirect to login with "Session expired" message</subtask>
        <subtask id="6.7">Manual test: click logout, verify redirect to login and refresh token cleared in database</subtask>
        <subtask id="6.8">Manual test: after logout, navigate to a protected page, verify redirect to login</subtask>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <ac id="1">Token automatically refreshed before expiration — When an access token is within 5 minutes of expiring, the system automatically refreshes it before making the API call, transparent to the user (NFR-2.1)</ac>
    <ac id="2">Sessions persist across browser tabs — Opening ditto in multiple browser tabs maintains the same session state; logging in on one tab does not require re-login on another</ac>
    <ac id="3">Session expiration redirects to login — If the session expires (refresh token also expired or invalidated), the user is redirected to the login page with the message: "Session expired. Please log in again."</ac>
    <ac id="4">Logout clears all tokens — On logout, all tokens are cleared client-side (cookies, session storage) and the refresh token is invalidated server-side</ac>
    <ac id="5">Refresh tokens rotate on each use — Each time a refresh token is used to obtain new tokens, the old refresh token is invalidated and a new one is issued</ac>
    <ac id="6">JWT access tokens expire after 24 hours — Access tokens have a 24-hour expiration TTL (NFR-2.1)</ac>
    <ac id="7">Refresh tokens expire after 7 days — Refresh tokens have a 7-day expiration TTL; users inactive for 7+ days must re-authenticate</ac>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/tech-spec-epic-6.md" title="Epic 6 Technical Specification" section="Story 6.8: Session Management">
        Token refresh flow, endpoint schemas (POST /api/auth/refresh), acceptance criteria, security requirements (NFR-2.1, NFR-2.4), and risk assessment for token refresh race conditions.
      </doc>
      <doc path="docs/tech-spec-epic-6.md" title="Epic 6 Technical Specification" section="Token Refresh Endpoint (Enhancement)">
        Defines the enhanced refresh endpoint request/response contract: POST /api/auth/refresh returns access_token, refresh_token, expires_in (86400). 401 response returns { error, code: "UNAUTHORIZED" }.
      </doc>
      <doc path="docs/tech-spec-epic-6.md" title="Epic 6 Technical Specification" section="Token Refresh Flow (Story 6.8)">
        Step-by-step token refresh workflow: check if access_token expiring in &lt;5min, call refresh, store new tokens, handle failure with redirect to login.
      </doc>
      <doc path="docs/architecture-frontend.md" title="Frontend Architecture" section="Authentication Flow">
        NextAuth v5 integration with three providers (Credentials, GitHub, Google). JWT callback stores access_token, refresh_token, backendUserId. Session callback injects tokens into session for API requests.
      </doc>
      <doc path="docs/architecture-frontend.md" title="Frontend Architecture" section="Session Management">
        SessionProvider wraps entire app. useSession() returns session/status. Refetches session periodically. Documents that token refresh in axios is NOT implemented (relies on NextAuth refresh) — the primary gap this story addresses.
      </doc>
      <doc path="docs/architecture-frontend.md" title="Frontend Architecture" section="Request Interceptor">
        Axios request interceptor automatically adds JWT bearer token to all requests from getSession(). Response interceptor handles errors with toast notifications.
      </doc>
      <doc path="docs/architecture-frontend.md" title="Frontend Architecture" section="authService">
        Existing service with refreshToken(refreshToken) method calling POST /api/refresh_token. Also has register(), login(), getMe() methods.
      </doc>
      <doc path="docs/architecture-backend.md" title="Backend Architecture" section="JWT Authentication">
        Access token TTL: 15 minutes (default, to be updated to 24h). Refresh token TTL: 7 days stored in users_auth.refresh_token. Auth middleware validates JWT on protected routes.
      </doc>
      <doc path="docs/architecture-backend.md" title="Backend Architecture" section="OAuth Integration">
        POST /api/oauth handler creates/finds user and returns JWT tokens. Frontend (NextAuth) authenticates with provider, then syncs with backend.
      </doc>
      <doc path="docs/architecture.md" title="Project Architecture" section="Authentication Pattern">
        JWT access tokens with 24-hour expiration target, refresh token rotation on use. All protected routes use existing auth middleware. File access via presigned S3 URLs tied to user_id.
      </doc>
      <doc path="docs/stories/6-5-error-handling-and-user-feedback.md" title="Story 6.5: Error Handling" section="Implementation">
        Established the centralized axios error interceptor pattern with toast notifications. The 401 interceptor for token refresh must run BEFORE the error toast interceptor to prevent showing "Unauthorized" toasts during normal refresh flow.
      </doc>
    </docs>

    <code>
      <file path="backend/internal/auth/jwt.go" kind="auth-utility" symbol="GenerateToken, ValidateToken, Claims" lines="1-57" reason="Core JWT generation/validation. Access token TTL is already 24h (line 29). No separate GenerateRefreshToken function exists — same GenerateToken is used for both access and refresh tokens with identical TTL, which is a gap for Task 1.">
      </file>
      <file path="backend/internal/handlers/auth.go" kind="handler" symbol="AuthHandler, RefreshToken, Logout, Login, Register, OAuthLogin" lines="1-334" reason="Primary file for Tasks 1-2. RefreshToken handler (line 206-245) currently returns only access_token — needs rotation (new refresh_token) and expires_in. Logout handler (line 190-204) already calls ClearRefreshToken.">
      </file>
      <file path="backend/internal/middleware/auth.go" kind="middleware" symbol="AuthMiddleware" lines="1-41" reason="JWT validation middleware for protected routes. Extracts user_id and user_email from Bearer token. No changes needed but important to understand auth flow.">
      </file>
      <file path="backend/internal/repository/user.go" kind="repository" symbol="UpdateRefreshToken, ValidateRefreshToken, ClearRefreshToken, GetUserAuth" lines="124-166" reason="Database operations for refresh tokens. UpdateRefreshToken stores token+expiry. ValidateRefreshToken checks token match and expiry. ClearRefreshToken nulls token on logout. All methods already exist.">
      </file>
      <file path="backend/internal/models/user.go" kind="model" symbol="UserAuth" lines="22-32" reason="UserAuth struct with RefreshToken (*string) and RefreshTokenExpiresAt (*time.Time) fields. Database columns already support token storage and expiry.">
      </file>
      <file path="backend/internal/routes/auth.go" kind="routes" symbol="RegisterAuthRoutes" lines="1-32" reason="Route registration. /refresh_token is public (rate-limited). /logout is protected (auth + CSRF middleware). No route changes needed.">
      </file>
      <file path="backend/pkg/errors/errors.go" kind="errors" symbol="ErrorUnauthorized, ErrorCode, AppError" lines="1-193" reason="Error code constants and response formatting. ErrorUnauthorized maps to 401 HTTP status. Used for refresh token error responses.">
      </file>
      <file path="frontend/src/auth.ts" kind="config" symbol="NextAuth config, refreshAccessToken, jwt callback, session callback" lines="1-150" reason="Primary file for Tasks 3-4. Already has refreshAccessToken() helper (line 10-34), JWT callback with proactive refresh (line 113-137), ACCESS_TOKEN_TTL (24h), REFRESH_BUFFER (5min). Needs: update refreshAccessToken to handle new response shape (refresh_token + expires_in), update JWT callback to store new refresh token on rotation.">
      </file>
      <file path="frontend/src/lib/axios.ts" kind="http-client" symbol="api interceptors, request/response handlers" lines="1-102" reason="Primary file for Task 3. Request interceptor (line 33-55) checks for RefreshTokenError and injects Bearer token. Response interceptor (line 57-100) handles 401 with signOut — needs to be enhanced with token refresh queue/mutex before falling through to signOut.">
      </file>
      <file path="frontend/src/providers/auth-provider.tsx" kind="provider" symbol="AuthProvider, SessionProvider" lines="1-12" reason="Task 4.3-4.4. Currently wraps children in bare SessionProvider with no props. Needs refetchOnWindowFocus={true} and refetchInterval for cross-tab session sync.">
      </file>
      <file path="frontend/src/services/auth-service.ts" kind="service" symbol="authService.refreshToken, authService.login" lines="1-59" reason="Existing refreshToken() calls POST /api/refresh_token. May be used from axios interceptor or auth.ts for refresh calls. Return type LoginResponse needs updating if refresh endpoint response shape changes.">
      </file>
      <file path="frontend/src/types/auth-type.ts" kind="types" symbol="LoginResponse, UserResponse, NextAuth module augmentation" lines="1-43" reason="Type definitions for auth. NextAuth User/Session/JWT interfaces augmented with accessToken, refreshToken, accessTokenExpires, error. May need updates if refresh response differs from LoginResponse.">
      </file>
      <file path="frontend/src/lib/errors.ts" kind="utility" symbol="getErrorMessage, isValidationError, ErrorResponse" lines="1-89" reason="Error message mapping. UNAUTHORIZED maps to 'Session expired. Please log in again.' Used by axios interceptor for error toasts. Token refresh 401s should bypass error toast.">
      </file>
      <file path="frontend/src/middleware.ts" kind="middleware" symbol="auth middleware, route matcher" lines="1-10" reason="Next.js middleware exports auth from NextAuth. Protects (app) routes. Redirects unauthenticated users to /login.">
      </file>
    </code>

    <dependencies>
      <backend ecosystem="go" manifest="backend/go.mod">
        <dep name="github.com/golang-jwt/jwt/v5" version="v5.2.2" relevance="JWT token generation and validation" />
        <dep name="github.com/gin-gonic/gin" version="v1.10.1" relevance="HTTP framework, request handlers, middleware" />
        <dep name="github.com/google/uuid" version="v1.6.0" relevance="User IDs in JWT claims" />
        <dep name="github.com/go-playground/validator/v10" version="v10.26.0" relevance="Request validation for refresh token input" />
        <dep name="github.com/jmoiron/sqlx" version="v1.4.0" relevance="Database queries for refresh token CRUD" />
        <dep name="golang.org/x/crypto" version="v0.44.0" relevance="bcrypt password hashing" />
      </backend>
      <frontend ecosystem="node" manifest="frontend/package.json">
        <dep name="next-auth" version="5.0.0-beta.29" relevance="Authentication, session management, JWT/session callbacks, token refresh" />
        <dep name="next" version="14.2.15" relevance="App Router, middleware, API routes" />
        <dep name="axios" version="^1.7.9" relevance="HTTP client with request/response interceptors for token injection and refresh" />
        <dep name="sonner" version="^2.0.7" relevance="Toast notifications for session expiry messages" />
        <dep name="zod" version="^3.24.2" relevance="Schema validation (used elsewhere, not directly for auth)" />
      </frontend>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="pattern">All auth changes must use the existing layered architecture: handlers → repository → database. No new middleware or services needed.</constraint>
    <constraint type="pattern">Backend error responses must use the standardized AppError format with ErrorCode (e.g., ErrorUnauthorized) which maps to HTTP status codes via ErrorCode.HTTPStatus().</constraint>
    <constraint type="pattern">Frontend error handling follows the centralized axios interceptor pattern from story 6.5. The 401 token-refresh interceptor must execute BEFORE the generic error toast interceptor to prevent false "Unauthorized" toasts during normal refresh.</constraint>
    <constraint type="pattern">NextAuth v5 beta.29 callback chain: signIn → jwt → session. Token storage lives in JWT callback; session callback exposes tokens to client. Server-side refresh happens in JWT callback using direct fetch (not axios).</constraint>
    <constraint type="security">Refresh tokens must be rotated on every use (AC-5). Old refresh token invalidated immediately on new token generation to prevent replay attacks.</constraint>
    <constraint type="security">No sensitive data (passwords, tokens, PII) in logs. Auth events (login, logout, token_refresh, failures) should use structured logging format.</constraint>
    <constraint type="integration">S3 presigned URL uploads bypass the axios instance entirely and use their own 15min expiry. Token refresh does not affect in-flight S3 uploads.</constraint>
    <constraint type="compatibility">The /refresh_token endpoint is public (rate-limited, no auth middleware). This is correct — the client sends the refresh token in the request body, not via Bearer header.</constraint>
    <constraint type="build">Both `npm run build` and `go build ./...` must pass after each task group (backend/frontend).</constraint>
  </constraints>

  <interfaces>
    <interface name="POST /api/refresh_token" kind="REST endpoint" path="backend/internal/routes/auth.go:20">
      <current>
        Request: { "refresh_token": string }
        Response (200): { "data": { "access_token": string } }
        Response (401): { "error": { "error": "invalid refresh token", "code": "UNAUTHORIZED" } }
      </current>
      <target>
        Request: { "refresh_token": string }
        Response (200): { "data": { "access_token": string, "refresh_token": string, "expires_in": 86400 } }
        Response (401): { "error": { "error": "Refresh token expired", "code": "UNAUTHORIZED" } }
      </target>
    </interface>
    <interface name="POST /api/logout" kind="REST endpoint" path="backend/internal/routes/auth.go:28">
      Request: (empty body, authenticated via Bearer token + CSRF)
      Response (200): { "data": { "message": "logged out successfully" } }
      Behavior: Clears refresh_token and refresh_token_expires_at in users_auth table.
    </interface>
    <interface name="refreshAccessToken()" kind="function" path="frontend/src/auth.ts:10-34">
      Called from NextAuth JWT callback for proactive refresh.
      Uses direct fetch (not axios) to POST /api/refresh_token.
      Returns { accessToken, accessTokenExpires } or null on failure.
      Needs update to also return and propagate new refresh_token from rotation.
    </interface>
    <interface name="authService.refreshToken()" kind="service method" path="frontend/src/services/auth-service.ts:37-47">
      Calls POST /api/refresh_token via axios instance.
      Returns LoginResponse type. May be used by axios interceptor for reactive refresh.
      Note: Using axios instance for refresh creates circular dependency risk — interceptor must skip refresh endpoint.
    </interface>
    <interface name="NextAuth JWT Callback" kind="callback" path="frontend/src/auth.ts:113-137">
      Stores accessToken, refreshToken, accessTokenExpires, backendUserId.
      Proactive refresh when token within REFRESH_BUFFER (5min) of expiry.
      Sets token.error = 'RefreshTokenError' on refresh failure.
    </interface>
    <interface name="NextAuth Session Callback" kind="callback" path="frontend/src/auth.ts:139-145">
      Exposes accessToken, refreshToken, error to client session.
      Axios request interceptor reads session.accessToken for Bearer header.
      Checks session.error === 'RefreshTokenError' to trigger signOut.
    </interface>
    <interface name="GenerateToken()" kind="function" path="backend/internal/auth/jwt.go:18-36">
      Generates HS256 JWT with UserID, Email claims and 24h expiry.
      Used for BOTH access and refresh tokens (same function, same TTL).
      Gap: refresh tokens should have 7-day TTL but currently get 24h from GenerateToken.
    </interface>
  </interfaces>

  <tests>
    <standards>
      Backend uses Go's testing package with testify assertions. Frontend uses the Next.js build process (npm run build) as primary validation since no test runner is configured yet. Manual testing is the primary verification method for auth flows. Structured logging of auth events (login, logout, token_refresh) should be verifiable in server output.
    </standards>
    <locations>
      <location>backend/**/*_test.go (Go unit tests, not yet created for auth)</location>
      <location>backend/test_api.sh (integration test script covering registration, login, JWT refresh, CRUD)</location>
      <location>Manual browser testing for frontend auth flows</location>
    </locations>
    <ideas>
      <idea ac="1">Verify proactive refresh triggers when access token is within 5min of expiry by inspecting NextAuth JWT callback behavior and network requests to /api/refresh_token</idea>
      <idea ac="2">Open two browser tabs, perform activity in one, switch to other tab — verify session is still valid and refetchOnWindowFocus triggers session refresh</idea>
      <idea ac="3">Expire both access and refresh tokens server-side (clear DB), then trigger an API call — verify redirect to /login with "Session expired" toast</idea>
      <idea ac="4">Click logout, then check users_auth table to verify refresh_token is NULL; verify browser has no lingering auth cookies</idea>
      <idea ac="5">Call /api/refresh_token, capture the new refresh_token in response, then attempt to use the OLD refresh_token — verify 401 (token reuse detection)</idea>
      <idea ac="6">Decode JWT access token after login and verify exp claim is ~24h from iat</idea>
      <idea ac="7">Decode refresh token and verify 7-day expiry; also check users_auth.refresh_token_expires_at in database</idea>
      <idea ac="1,3">Simulate multiple concurrent 401 failures — verify only one refresh call is made (check network tab), others queue and retry</idea>
    </ideas>
  </tests>
</story-context>
